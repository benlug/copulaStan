[{"path":"https://benlug.github.io/copulaStan/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 copulaStan authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"vignette, demonstrate fit bivariate Gaussian copula models using copulaStan package. provide examples fitting Gaussian copula models different types marginals, including normal, lognormal distributions.","code":"library(copulaStan) library(copula)"},{"path":[]},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"normal-lognormal-marginals","dir":"Articles","previous_headings":"Introduction > Example: Gaussian Copula","what":"Normal + Lognormal Marginals","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"","code":"seed <- 2024 set.seed(seed) true_rho <- 0.5 n <- 2000    margins <- c(\"norm\", \"lnorm\") params <- list(list(mean = 0.8, sd = 2), list(meanlog = 0, sdlog = 0.8)) cop <- normalCopula(param = true_rho, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"gaussian\", marginals = c(\"normal\", \"lognormal\"),                              seed = seed) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 0.002766 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 27.66 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 11.892 seconds (Warm-up) ## Chain 1:                11.525 seconds (Sampling) ## Chain 1:                23.417 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 0.001615 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 16.15 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 12.236 seconds (Warm-up) ## Chain 2:                10.953 seconds (Sampling) ## Chain 2:                23.189 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 0.00162 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 16.2 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 12.288 seconds (Warm-up) ## Chain 3:                11.878 seconds (Sampling) ## Chain 3:                24.166 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 0.001611 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 16.11 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 11.554 seconds (Warm-up) ## Chain 4:                11.583 seconds (Sampling) ## Chain 4:                23.137 seconds (Total) ## Chain 4: fit ## Inference for Stan model: anon_model. ## 4 chains, each with iter=2000; warmup=1000; thin=1;  ## post-warmup draws per chain=1000, total post-warmup draws=4000. ##  ##               mean se_mean   sd     2.5%      25%      50%      75%    97.5% ## mu1[1]        0.79    0.00 0.05     0.70     0.75     0.79     0.82     0.88 ## sigma1[1]     2.03    0.00 0.03     1.97     2.01     2.03     2.06     2.10 ## mu2[1]        0.02    0.00 0.02    -0.01     0.01     0.02     0.03     0.06 ## sigma2[1]     0.79    0.00 0.01     0.76     0.78     0.79     0.79     0.81 ## rho[1]        0.53    0.00 0.02     0.50     0.52     0.53     0.54     0.56 ## lp__      -4448.13    0.04 1.61 -4452.09 -4448.96 -4447.79 -4446.94 -4446.01 ##           n_eff Rhat ## mu1[1]     3576    1 ## sigma1[1]  3748    1 ## mu2[1]     3482    1 ## sigma2[1]  3680    1 ## rho[1]     3459    1 ## lp__       1771    1 ##  ## Samples were drawn using NUTS(diag_e) at Tue Jul 16 17:31:16 2024. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at  ## convergence, Rhat=1)."},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"normal-exponential-marginals","dir":"Articles","previous_headings":"Introduction > Example: Gaussian Copula","what":"Normal + Exponential Marginals","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"","code":"seed <- 2024 set.seed(seed) true_rho <- 0.5 n <- 2000    margins <- c(\"norm\", \"exp\") params <- list(list(mean = 0.8, sd = 2), list(rate = 1)) cop <- normalCopula(param = true_rho, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"gaussian\", marginals = c(\"normal\", \"exponential\"),                              seed = seed) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 0.001494 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 14.94 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 9.993 seconds (Warm-up) ## Chain 1:                8.99 seconds (Sampling) ## Chain 1:                18.983 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 0.001486 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 14.86 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 10.212 seconds (Warm-up) ## Chain 2:                9.527 seconds (Sampling) ## Chain 2:                19.739 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 0.001468 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 14.68 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 10.353 seconds (Warm-up) ## Chain 3:                10.524 seconds (Sampling) ## Chain 3:                20.877 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 0.001498 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 14.98 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 9.851 seconds (Warm-up) ## Chain 4:                10.451 seconds (Sampling) ## Chain 4:                20.302 seconds (Total) ## Chain 4: fit ## Inference for Stan model: anon_model. ## 4 chains, each with iter=2000; warmup=1000; thin=1;  ## post-warmup draws per chain=1000, total post-warmup draws=4000. ##  ##                mean se_mean   sd     2.5%      25%      50%      75%    97.5% ## mu1[1]         0.77    0.00 0.04     0.69     0.74     0.77     0.80     0.86 ## sigma1[1]      2.05    0.00 0.03     1.98     2.02     2.05     2.07     2.11 ## lambda2[1]     0.99    0.00 0.02     0.94     0.97     0.99     1.00     1.03 ## rho[1]         0.54    0.00 0.01     0.51     0.53     0.54     0.55     0.57 ## lp__       -4122.40    0.03 1.43 -4125.98 -4123.15 -4122.07 -4121.35 -4120.64 ##            n_eff Rhat ## mu1[1]      3361    1 ## sigma1[1]   3234    1 ## lambda2[1]  3272    1 ## rho[1]      3169    1 ## lp__        2162    1 ##  ## Samples were drawn using NUTS(diag_e) at Tue Jul 16 17:32:37 2024. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at  ## convergence, Rhat=1)."},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"beta-beta-marginals","dir":"Articles","previous_headings":"Introduction > Example: Gaussian Copula","what":"Beta + Beta Marginals","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"","code":"seed <- 2024 set.seed(seed) true_rho <- 0.5 n <- 2000    # Parameters for beta distributions alpha1 <- 2 beta1 <- 5 alpha2 <- 3 beta2 <- 4  # Generate beta distributed data margins <- c(\"beta\", \"beta\") params <- list(list(shape1 = alpha1, shape2 = beta1), list(shape1 = alpha2, shape2 = beta2)) cop <- normalCopula(param = true_rho, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"gaussian\", marginals = c(\"beta\", \"beta\"),                              seed = seed) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 0.003532 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 35.32 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 132.557 seconds (Warm-up) ## Chain 1:                162.965 seconds (Sampling) ## Chain 1:                295.522 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 0.00346 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 34.6 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 140.862 seconds (Warm-up) ## Chain 2:                141.042 seconds (Sampling) ## Chain 2:                281.904 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 0.003486 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 34.86 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 138.374 seconds (Warm-up) ## Chain 3:                144.726 seconds (Sampling) ## Chain 3:                283.1 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 0.003487 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 34.87 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 142.18 seconds (Warm-up) ## Chain 4:                124.105 seconds (Sampling) ## Chain 4:                266.285 seconds (Total) ## Chain 4: fit ## Inference for Stan model: anon_model. ## 4 chains, each with iter=2000; warmup=1000; thin=1;  ## post-warmup draws per chain=1000, total post-warmup draws=4000. ##  ##              mean se_mean   sd    2.5%     25%     50%     75%   97.5% n_eff ## alpha1[1]    1.94    0.00 0.06    1.83    1.90    1.94    1.97    2.05  1816 ## beta1[1]     4.85    0.00 0.15    4.55    4.74    4.84    4.95    5.16  2027 ## alpha2[1]    3.13    0.00 0.09    2.95    3.06    3.13    3.19    3.32  1959 ## beta2[1]     4.09    0.00 0.12    3.85    4.01    4.09    4.17    4.33  1997 ## rho[1]       0.53    0.00 0.02    0.50    0.52    0.53    0.54    0.56  2168 ## lp__      1986.30    0.04 1.56 1982.51 1985.46 1986.62 1987.45 1988.35  1627 ##           Rhat ## alpha1[1]    1 ## beta1[1]     1 ## alpha2[1]    1 ## beta2[1]     1 ## rho[1]       1 ## lp__         1 ##  ## Samples were drawn using NUTS(diag_e) at Tue Jul 16 17:51:26 2024. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at  ## convergence, Rhat=1)."},{"path":[]},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"normal-lognormal-marginals-1","dir":"Articles","previous_headings":"Introduction > Example: Clatyon Copula","what":"Normal + Lognormal Marginals","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"","code":"seed <- 2024 set.seed(seed) true_theta <- 2.0 n <- 2000    margins <- c(\"norm\", \"lnorm\") params <- list(list(mean = 0.8, sd = 2), list(meanlog = 0, sdlog = 0.8)) cop <- claytonCopula(param = true_theta, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"clayton\", marginals = c(\"normal\", \"lognormal\"),                              seed = seed) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 0.00226 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 22.6 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 24.424 seconds (Warm-up) ## Chain 1:                19.103 seconds (Sampling) ## Chain 1:                43.527 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 0.002052 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 20.52 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 24.557 seconds (Warm-up) ## Chain 2:                23.902 seconds (Sampling) ## Chain 2:                48.459 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 0.00205 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 20.5 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 23.649 seconds (Warm-up) ## Chain 3:                23.453 seconds (Sampling) ## Chain 3:                47.102 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 0.002074 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 20.74 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 23.795 seconds (Warm-up) ## Chain 4:                25.364 seconds (Sampling) ## Chain 4:                49.159 seconds (Total) ## Chain 4: fit ## Inference for Stan model: anon_model. ## 4 chains, each with iter=2000; warmup=1000; thin=1;  ## post-warmup draws per chain=1000, total post-warmup draws=4000. ##  ##               mean se_mean   sd     2.5%      25%      50%      75%    97.5% ## mu1[1]        0.80    0.00 0.04     0.72     0.78     0.80     0.83     0.89 ## sigma1[1]     1.98    0.00 0.03     1.93     1.96     1.98     2.00     2.04 ## mu2[1]        0.01    0.00 0.02    -0.02     0.00     0.01     0.02     0.05 ## sigma2[1]     0.79    0.00 0.01     0.76     0.78     0.79     0.80     0.81 ## theta[1]      2.07    0.00 0.09     1.90     2.01     2.07     2.12     2.24 ## lp__      -3831.45    0.04 1.66 -3835.67 -3832.29 -3831.11 -3830.23 -3829.30 ##           n_eff Rhat ## mu1[1]     1924    1 ## sigma1[1]  1879    1 ## mu2[1]     2141    1 ## sigma2[1]  1953    1 ## theta[1]   1623    1 ## lp__       1638    1 ##  ## Samples were drawn using NUTS(diag_e) at Tue Jul 16 17:54:35 2024. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at  ## convergence, Rhat=1)."},{"path":[]},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"normal-lognormal-marginals-2","dir":"Articles","previous_headings":"Introduction > Example: Joe Copula","what":"Normal + Lognormal Marginals","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"","code":"seed <- 2024 set.seed(seed) true_theta <- 2.0 n <- 2000    margins <- c(\"norm\", \"lnorm\") params <- list(list(mean = 0.8, sd = 2), list(meanlog = 0, sdlog = 0.8)) cop <- joeCopula(param = true_theta, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"joe\", marginals = c(\"normal\", \"lognormal\"),                              seed = seed) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 0.002278 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 22.78 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 19.143 seconds (Warm-up) ## Chain 1:                19.38 seconds (Sampling) ## Chain 1:                38.523 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 0.00226 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 22.6 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 20.59 seconds (Warm-up) ## Chain 2:                18.114 seconds (Sampling) ## Chain 2:                38.704 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 0.002181 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 21.81 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 20.231 seconds (Warm-up) ## Chain 3:                21.777 seconds (Sampling) ## Chain 3:                42.008 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 0.002249 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 22.49 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) ## Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) ## Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) ## Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) ## Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 19.684 seconds (Warm-up) ## Chain 4:                21.814 seconds (Sampling) ## Chain 4:                41.498 seconds (Total) ## Chain 4: fit ## Inference for Stan model: anon_model. ## 4 chains, each with iter=2000; warmup=1000; thin=1;  ## post-warmup draws per chain=1000, total post-warmup draws=4000. ##  ##               mean se_mean   sd     2.5%      25%      50%      75%    97.5% ## mu1[1]        3.88    0.00 0.06     3.75     3.84     3.88     3.92     4.01 ## sigma1[1]     2.92    0.00 0.05     2.83     2.89     2.92     2.95     3.01 ## mu2[1]        1.26    0.00 0.03     1.21     1.24     1.26     1.28     1.31 ## sigma2[1]     1.21    0.00 0.02     1.17     1.20     1.21     1.22     1.25 ## theta[1]      2.21    0.00 0.06     2.10     2.17     2.21     2.25     2.32 ## lp__      -6852.44    0.04 1.56 -6856.48 -6853.23 -6852.09 -6851.31 -6850.37 ##           n_eff Rhat ## mu1[1]     2445    1 ## sigma1[1]  2832    1 ## mu2[1]     2310    1 ## sigma2[1]  2669    1 ## theta[1]   2710    1 ## lp__       1836    1 ##  ## Samples were drawn using NUTS(diag_e) at Tue Jul 16 17:57:18 2024. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at  ## convergence, Rhat=1)."},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"derivation-of-gaussian-copula-log-likelihood","dir":"Articles","previous_headings":"","what":"Derivation of Gaussian Copula Log Likelihood","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"derivation Gaussian copula likelihood implemented package. Transformation Uniform Marginals: U1=F1(X1),U2=F2(X2) U_1 = F_1(X_1), \\quad U_2 = F_2(X_2)  F1F_1 F2F_2 CDFs marginals. Transformation Standard Normal: Z1=Φ−1(U1),Z2=Φ−1(U2) Z_1 = \\Phi^{-1}(U_1), \\quad Z_2 = \\Phi^{-1}(U_2)  Φ−1\\Phi^{-1} inverse CDF standard normal distribution. Bivariate Normal Density: ϕρ(z1,z2)=12π1−ρ2exp(−12(1−ρ2)(z12+z22−2ρz1z2)) \\phi_{\\rho}(z_1, z_2) = \\frac{1}{2\\pi\\sqrt{1-\\rho^2}} \\exp\\left( -\\frac{1}{2(1-\\rho^2)}(z_1^2 + z_2^2 - 2\\rho z_1 z_2) \\right) Standard Normal Marginal Density: ϕ(z)=12πexp(−z22) \\phi(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left( -\\frac{z^2}{2} \\right) Copula Density: c(u1,u2;ρ)=ϕρ(z1,z2)ϕ(z1)ϕ(z2) c(u_1, u_2; \\rho) = \\frac{\\phi_{\\rho}(z_1, z_2)}{\\phi(z_1) \\phi(z_2)}  Substituting expressions ϕρ\\phi_{\\rho} ϕ\\phi: c(u1,u2;ρ)=12π1−ρ2exp(−12(1−ρ2)(z12+z22−2ρz1z2))(12πexp(−z122))(12πexp(−z222)) c(u_1, u_2; \\rho) = \\frac{\\frac{1}{2\\pi\\sqrt{1-\\rho^2}} \\exp\\left( -\\frac{1}{2(1-\\rho^2)}(z_1^2 + z_2^2 - 2\\rho z_1 z_2) \\right)}{\\left( \\frac{1}{\\sqrt{2\\pi}} \\exp\\left( -\\frac{z_1^2}{2} \\right) \\right) \\left( \\frac{1}{\\sqrt{2\\pi}} \\exp\\left( -\\frac{z_2^2}{2} \\right) \\right)}  Simplifying, get: c(u1,u2;ρ)=11−ρ2exp(−12(1−ρ2)(z12+z22−2ρz1z2)+z122+z222) c(u_1, u_2; \\rho) = \\frac{1}{\\sqrt{1-\\rho^2}} \\exp\\left( -\\frac{1}{2(1-\\rho^2)}(z_1^2 + z_2^2 - 2\\rho z_1 z_2) + \\frac{z_1^2}{2} + \\frac{z_2^2}{2} \\right) Log Likelihood: logc(u1,u2;ρ)=−12log(1−ρ2)+ρz1z2−ρ2(z12+z22)2(1−ρ2) \\log c(u_1, u_2; \\rho) = -\\frac{1}{2} \\log(1-\\rho^2) + \\frac{\\rho z_1 z_2 - \\rho^2 (z_1^2 + z_2^2)}{2(1-\\rho^2)}","code":""},{"path":"https://benlug.github.io/copulaStan/articles/copulaStan-intro.html","id":"derivation-of-clayton-copula-log-likelihood","dir":"Articles","previous_headings":"Derivation of Gaussian Copula Log Likelihood","what":"Derivation of Clayton Copula Log Likelihood","title":"copulaStan: Fitting Bivariate Gaussian and Clayton Copulas","text":"derivation Clayton copula likelihood implemented package. Clayton copula defined : C(u,v;θ)=(u−θ+v−θ−1)−1θ C(u, v; \\theta) = \\left(u^{-\\theta} + v^{-\\theta} - 1\\right)^{-\\frac{1}{\\theta}}  θ>0\\theta > 0. copula density function c(u,v;θ)c(u, v; \\theta) obtained differentiating copula function: c(u,v;θ)=∂2C(u,v;θ)∂u∂v c(u, v; \\theta) = \\frac{\\partial^2 C(u, v; \\theta)}{\\partial u \\partial v} First, differentiate C(u,v;θ)C(u, v; \\theta) respect uu: ∂C(u,v;θ)∂u=∂∂u(u−θ+v−θ−1)−1θ \\frac{\\partial C(u, v; \\theta)}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta}} =−1θ(u−θ+v−θ−1)−1θ−1⋅(−θ)u−θ−1 = -\\frac{1}{\\theta} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 1} \\cdot (-\\theta) u^{-\\theta - 1} =u−θ−1(u−θ+v−θ−1)−1θ−1 = u^{-\\theta - 1} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 1} Next, differentiate result respect vv: ∂2C(u,v;θ)∂u∂v=∂∂v(u−θ−1(u−θ+v−θ−1)−1θ−1) \\frac{\\partial^2 C(u, v; \\theta)}{\\partial u \\partial v} = \\frac{\\partial}{\\partial v} \\left( u^{-\\theta - 1} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 1} \\right) =u−θ−1⋅(−1θ−1)(u−θ+v−θ−1)−1θ−2⋅(−θ)v−θ−1 = u^{-\\theta - 1} \\cdot \\left( -\\frac{1}{\\theta} - 1 \\right) \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 2} \\cdot (-\\theta) v^{-\\theta - 1} =(θ+1)u−θ−1v−θ−1(u−θ+v−θ−1)−1θ−2 = (\\theta + 1) u^{-\\theta - 1} v^{-\\theta - 1} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 2} Therefore, Clayton copula density function : c(u,v;θ)=(θ+1)u−θ−1v−θ−1(u−θ+v−θ−1)−1θ−2 c(u, v; \\theta) = (\\theta + 1) u^{-\\theta - 1} v^{-\\theta - 1} \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right)^{-\\frac{1}{\\theta} - 2} Taking natural logarithm, get log likelihood: logc(u,v;θ)=log(θ+1)+(−θ−1)(logu+logv)+(−1θ−2)log(u−θ+v−θ−1) \\log c(u, v; \\theta) = \\log(\\theta + 1) + (-\\theta - 1) (\\log u + \\log v) + \\left( -\\frac{1}{\\theta} - 2 \\right) \\log \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right) =log(θ+1)+(−θ−1)(logu+logv)−(2θ+1θ)log(u−θ+v−θ−1) = \\log(\\theta + 1) + (-\\theta - 1) (\\log u + \\log v) - \\left( \\frac{2\\theta + 1}{\\theta} \\right) \\log \\left( u^{-\\theta} + v^{-\\theta} - 1 \\right) Thus, log likelihood Clayton copula : logc(u,v;θ)=log(1+θ)+(−θ−1)(logu+logv)−2θ+1θlog(u−θ+v−θ−1) \\log c(u, v; \\theta) = \\log(1 + \\theta) + (-\\theta - 1) (\\log u + \\log v) - \\frac{2\\theta + 1}{\\theta} \\log (u^{-\\theta} + v^{-\\theta} - 1)","code":""},{"path":"https://benlug.github.io/copulaStan/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Benedikt Lugauer. Author, maintainer.","code":""},{"path":"https://benlug.github.io/copulaStan/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lugauer B (2024). copulaStan: Fit Bivariate Gaussian Clayton Copula Models Using Stan. R package version 0.4.0, https://benlug.github.io/copulaStan/.","code":"@Manual{,   title = {copulaStan: Fit Bivariate Gaussian and Clayton Copula Models Using Stan},   author = {Benedikt Lugauer},   year = {2024},   note = {R package version 0.4.0},   url = {https://benlug.github.io/copulaStan/}, }"},{"path":"https://benlug.github.io/copulaStan/index.html","id":"copulastan-","dir":"","previous_headings":"","what":"Fit Bivariate Gaussian and Clayton Copula Models Using Stan","title":"Fit Bivariate Gaussian and Clayton Copula Models Using Stan","text":"copulaStan package provides functions fit bivariate Gaussian Clayton copula models using Stan. models can handle normal non-normal marginals.","code":""},{"path":"https://benlug.github.io/copulaStan/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fit Bivariate Gaussian and Clayton Copula Models Using Stan","text":"can install development version copulaStan GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"benlug/copulaStan\")"},{"path":"https://benlug.github.io/copulaStan/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Fit Bivariate Gaussian and Clayton Copula Models Using Stan","text":"basic example shows fit bivariate Gaussian copula model: example fitting bivariate Clayton copula model:","code":"library(copula) library(copulaStan)  set.seed(123) true_rho <- 0.5 n <- 1000  margins <- c(\"norm\", \"norm\") params <- list(list(mean = 0, sd = 1), list(mean = 0, sd = 1)) cop <- normalCopula(param = true_rho, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) U <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(U,                              copula = \"gaussian\", marginals = margins,                              seed = 123) fit library(copula) library(copulaStan)  seed <- 2024 set.seed(seed) true_theta <- 2.0 n <- 2000    margins <- c(\"norm\", \"lnorm\") params <- list(list(mean = 0.8, sd = 2), list(meanlog = 0, sdlog = 0.8)) cop <- claytonCopula(param = true_theta, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                              copula = \"clayton\", marginals = margins,                             seed = seed) fit"},{"path":"https://benlug.github.io/copulaStan/reference/fit_bivariate_copula.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","title":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","text":"`fit_bivariate_copula` function fits bivariate copula model data optional marginal parameter estimation. supports Gaussian, Clayton, Joe copulas, allows specifying normal, lognormal, exponential, beta marginal distributions variable. function utilizes Stan Bayesian inference.","code":""},{"path":"https://benlug.github.io/copulaStan/reference/fit_bivariate_copula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","text":"","code":"fit_bivariate_copula(   U,   copula,   marginals,   iter = 2000,   chains = 4,   warmup = 1000,   thin = 1,   seed = NULL,   control = list(adapt_delta = 0.8, max_treedepth = 10),   cores = 1 )"},{"path":"https://benlug.github.io/copulaStan/reference/fit_bivariate_copula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","text":"U Data matrix observed marginals, two variables. copula type copula fit. Options \"gaussian\", \"clayton\", \"joe\". marginals list specifying marginal distributions variable. Options \"normal\", \"lognormal\", \"exponential\", \"beta\". iter Number iterations chain. Default 2000. chains Number chains. Default 4. warmup Number warmup iterations per chain. Default 1000. thin Thinning rate. Default 1. seed Random seed. Default NULL. control list parameters control sampler's behavior. Default list(adapt_delta = 0.8, max_treedepth = 10). cores Number cores use parallel processing. Default 1.","code":""},{"path":"https://benlug.github.io/copulaStan/reference/fit_bivariate_copula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","text":"list containing: fit Stan model object.","code":""},{"path":"https://benlug.github.io/copulaStan/reference/fit_bivariate_copula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Bivariate Copula Model with Optional Marginal Parameter Estimation — fit_bivariate_copula","text":"","code":"if (FALSE) { # \\dontrun{ library(copulaStan) library(copula)  seed <- 2024 set.seed(seed) true_rho <- 0.5 n <- 2000  margins <- c(\"norm\", \"lnorm\") params <- list(list(mean = 0.8, sd = 2), list(meanlog = 0, sdlog = 0.8)) cop <- normalCopula(param = true_rho, dim = 2) mvdc_copula <- mvdc(cop, margins = margins, paramMargins = params) data <- rMvdc(n, mvdc_copula)  fit <- fit_bivariate_copula(data,                             copula = \"gaussian\", marginals = c(\"normal\", \"lognormal\"),                             seed = seed) } # }"},{"path":[]},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"copulaStan 0.4.0","text":"Now supports following marginals: “normal”, “lognormal”, “exponential”, “beta”.","code":""},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"copulaStan 0.4.0","text":"Fixed minor bugs related marginal distribution handling.","code":""},{"path":[]},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"copulaStan 0.3.1","text":"Unified copula functions single fit_bivariate_copula function.","code":""},{"path":[]},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"copulaStan 0.3.0","text":"Supports marginals: “normal”, “lognormal”. Included vignette.","code":""},{"path":[]},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"copulaStan 0.2.0","text":"Added functions fit Clayton copula models. Improved documentation.","code":""},{"path":[]},{"path":"https://benlug.github.io/copulaStan/news/index.html","id":"initial-release-0-1-0","dir":"Changelog","previous_headings":"","what":"Initial Release","title":"copulaStan 0.1.0","text":"Introduced package basic functionality fit bivariate Gaussian copula models. Added initial documentation examples usage.","code":""}]
